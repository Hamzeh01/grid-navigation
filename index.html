<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Shortest Path Finder</title>
    <style>
      #gridCanvas {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <h1>Shortest Path Finder</h1>
    <form id="pathForm">
      <label for="fileInput">Upload Grid File:</label>
      <input type="file" id="fileInput" accept=".txt" required /><br /><br />
      <label for="startX">Start X:</label>
      <input type="number" id="startX" required />
      <label for="startY">Start Y:</label>
      <input type="number" id="startY" required /><br /><br />
      <label for="endX">End X:</label>
      <input type="number" id="endX" required />
      <label for="endY">End Y:</label>
      <input type="number" id="endY" required /><br /><br />
      <label for="algorithm">Select Algorithm:</label>
      <select id="algorithm" required>
        <option value="gbfs">GBFS</option>
        <option value="astar">A*</option></select
      ><br /><br />
      <button type="submit">Find Path</button>
    </form>
    <h2>Output</h2>
    <p id="output"></p>
    <canvas id="gridCanvas" width="1024" height="1024"></canvas>

    <script>
      document
        .getElementById("pathForm")
        .addEventListener("submit", function (event) {
          event.preventDefault();
          const fileInput = document.getElementById("fileInput").files[0];
          const startX = parseInt(document.getElementById("startX").value);
          const startY = parseInt(document.getElementById("startY").value);
          const endX = parseInt(document.getElementById("endX").value);
          const endY = parseInt(document.getElementById("endY").value);
          const algorithm = document.getElementById("algorithm").value;

          if (fileInput) {
            const reader = new FileReader();
            reader.onload = function (e) {
              const grid = e.target.result
                .split("\n")
                .map((line) => line.split(""));
              if (algorithm === "gbfs") {
                findPathGBFS(grid, startX, startY, endX, endY);
              } else {
                findPathAStar(grid, startX, startY, endX, endY);
              }
            };
            reader.readAsText(fileInput);
          }
        });

      function findPathGBFS(grid, startX, startY, endX, endY) {
        const startTime = performance.now();
        const path = searchPath(
          grid,
          startX,
          startY,
          endX,
          endY,
          heuristicGBFS
        );
        const endTime = performance.now();
        displayOutput(path, endTime - startTime);
        drawGrid(grid, path);
      }

      function findPathAStar(grid, startX, startY, endX, endY) {
        const startTime = performance.now();
        const path = searchPath(
          grid,
          startX,
          startY,
          endX,
          endY,
          heuristicAStar
        );
        const endTime = performance.now();
        displayOutput(path, endTime - startTime);
        drawGrid(grid, path);
      }

      function searchPath(grid, startX, startY, endX, endY, heuristic) {
        const directions = [
          [0, 1],
          [1, 0],
          [0, -1],
          [-1, 0],
        ];
        const priorityQueue = [{ x: startX, y: startY, cost: 0 }];
        const visited = new Set();
        visited.add(`${startX},${startY}`);
        const cameFrom = {};
        const costSoFar = {};
        costSoFar[`${startX},${startY}`] = 0;

        while (priorityQueue.length > 0) {
          priorityQueue.sort((a, b) => a.cost - b.cost);
          const current = priorityQueue.shift();

          if (current.x === endX && current.y === endY) {
            return reconstructPath(cameFrom, startX, startY, endX, endY);
          }

          for (const [dx, dy] of directions) {
            const newX = current.x + dx;
            const newY = current.y + dy;
            const newKey = `${newX},${newY}`;

            if (isValid(grid, newX, newY) && !visited.has(newKey)) {
              const newCost = costSoFar[`${current.x},${current.y}`] + 1;
              costSoFar[newKey] = newCost;
              const priority = newCost + heuristic(newX, newY, endX, endY);
              priorityQueue.push({ x: newX, y: newY, cost: priority });
              visited.add(newKey);
              cameFrom[newKey] = `${current.x},${current.y}`;
            }
          }
        }
        return null;
      }

      function heuristicGBFS(x, y, endX, endY) {
        return Math.abs(x - endX) + Math.abs(y - endY);
      }

      function heuristicAStar(x, y, endX, endY) {
        return Math.abs(x - endX) + Math.abs(y - endY);
      }

      function isValid(grid, x, y) {
        return (
          x >= 0 &&
          y >= 0 &&
          x < grid.length &&
          y < grid[0].length &&
          grid[x][y] === "."
        );
      }

      function reconstructPath(cameFrom, startX, startY, endX, endY) {
        let current = `${endX},${endY}`;
        const path = [];
        while (current !== `${startX},${startY}`) {
          path.push(current);
          current = cameFrom[current];
        }
        path.push(`${startX},${startY}`);
        return path.reverse();
      }

      function displayOutput(path, runtime) {
        if (path) {
          document.getElementById("output").innerText = `Path found with cost ${
            path.length - 1
          } in ${runtime.toFixed(2)} ms.`;
        } else {
          document.getElementById("output").innerText = "No path found.";
        }
      }

      function drawGrid(grid, path) {
        const canvas = document.getElementById("gridCanvas");
        const ctx = canvas.getContext("2d");
        const scale = canvas.width / grid.length;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (let x = 0; x < grid.length; x++) {
          for (let y = 0; y < grid[x].length; y++) {
            ctx.fillStyle = grid[x][y] === "." ? "#ffffff" : "#000000";
            ctx.fillRect(y * scale, x * scale, scale, scale);
          }
        }

        if (path) {
          ctx.fillStyle = "#ff0000";
          for (const p of path) {
            const [x, y] = p.split(",").map(Number);
            ctx.fillRect(y * scale, x * scale, scale, scale);
          }
        }
      }
    </script>
  </body>
</html>
